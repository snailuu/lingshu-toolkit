{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "title": "reactUseControllableValue",
  "name": "reactUseControllableValue",
  "description": "reactUseControllableValue",
  "registryDependencies": [
    "https://cmtlyt.github.io/lingshu-toolkit/r/reactUseValidData.json"
  ],
  "dependencies": [
    "react",
    "@s"
  ],
  "type": "registry:item",
  "files": [
    {
      "path": "src/react/use-controllable-value/index.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/react/use-controllable-value/index.ts",
      "content": "import { useEffect, useEffectEvent, useRef, useState } from 'react';\nimport { $dt, $t, useValidData } from '../use-valid-data';\n\ninterface UseControllableValueOptions<Ks extends PropertyKey = PropertyKey, P extends Ks | (string & {}) = 'value'> {\n  defaultValue: any;\n  defaultValuePropName: Ks;\n  valuePropName: P;\n  trigger: Ks;\n}\n\nconst validInfo = $dt<UseControllableValueOptions>({\n  defaultValuePropName: $t.validString('defaultValue'),\n  valuePropName: $t.validString('value'),\n  trigger: $t.validString('onChange'),\n});\n\nexport type PublicUseControllableValueOptions<\n  Ks extends PropertyKey = PropertyKey,\n  P extends Ks | (string & {}) = 'value',\n> = Partial<UseControllableValueOptions<Ks, P>>;\n\ntype ParseDefaultValue<\n  OT extends Record<PropertyKey, any>,\n  O extends PublicUseControllableValueOptions,\n> = O['defaultValuePropName'] extends keyof OT ? OT[O['defaultValuePropName']] : O['defaultValue'];\n\ntype Defaultize<\n  OT extends Record<PropertyKey, any>,\n  P extends keyof OT | (string & {}),\n  O extends PublicUseControllableValueOptions,\n> = P extends keyof OT\n  ? undefined extends OT[P]\n    ? OT[P] & ParseDefaultValue<OT, O>\n    : OT[P]\n  : ParseDefaultValue<OT, O>;\n\ntype ValueType<\n  T extends Record<PropertyKey, any>,\n  O extends PublicUseControllableValueOptions<PropertyKey, any>,\n> = O['valuePropName'] extends keyof T ? Defaultize<T, O['valuePropName'], O> : Defaultize<T, 'value', O>;\n\n/**\n * 受控组件 value 逻辑切换, 如果传递了 value 则走受控逻辑, 否则走非受控逻辑\n */\nexport function useControllableValue<\n  T extends Record<PropertyKey, any>,\n  P extends keyof T | (string & {}) = PropertyKey,\n  O extends PublicUseControllableValueOptions<keyof T, P> = PublicUseControllableValueOptions<keyof T, P>,\n>(props = {} as T, options = {} as O) {\n  const { result: validOptions } = useValidData(options as UseControllableValueOptions, validInfo) as {\n    result: UseControllableValueOptions;\n  };\n  const { defaultValue: _defaultValue, trigger, valuePropName, defaultValuePropName } = validOptions;\n  const {\n    [valuePropName]: propValue,\n    [defaultValuePropName]: defaultValue = _defaultValue,\n    [trigger]: emitChange,\n  } = props;\n\n  const hasValueRef = useRef(Boolean(Reflect.getOwnPropertyDescriptor(props, valuePropName)));\n  const isFirstRenderRef = useRef(true);\n\n  const [ctrlValue, setCtrlValue] = useState(hasValueRef.current ? (propValue as ValueType<T, O>) : defaultValue);\n\n  const setValue = useEffectEvent((value: ValueType<T, O>, ...args: any[]) => {\n    if (typeof emitChange === 'function') {\n      emitChange(value, ...args);\n    }\n    if (!hasValueRef.current) {\n      setCtrlValue(value);\n    }\n  });\n\n  useEffect(() => {\n    if (isFirstRenderRef.current || !hasValueRef.current) {\n      isFirstRenderRef.current = false;\n      return;\n    }\n    setCtrlValue(propValue as ValueType<T, O>);\n  }, [propValue]);\n\n  return [ctrlValue, setValue] as [ValueType<T, O>, typeof setValue];\n}\n"
    }
  ]
}