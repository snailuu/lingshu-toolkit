{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "title": "reactUseControllableValue",
  "name": "reactUseControllableValue",
  "description": "reactUseControllableValue",
  "registryDependencies": [
    "./src/public/r/sharedTypes.json",
    "./src/public/r/reactUseValidData.json"
  ],
  "dependencies": [
    "react",
    "@s"
  ],
  "type": "registry:item",
  "files": [
    {
      "path": "src/react/use-controllable-value/index.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/react/use-controllable-value/index.ts",
      "content": "import type { NotUnion } from '../../shared/types';\nimport { useEffect, useEffectEvent, useRef, useState } from 'react';\nimport { $dt, $t, useValidData } from '../use-valid-data';\n\ninterface UseControllableValueOptions<Ks extends PropertyKey = PropertyKey, P extends Ks | (string & {}) = 'value'> {\n  defaultValue: any;\n  defaultValuePropName: Ks;\n  valuePropName: P;\n  trigger: Ks;\n}\n\nconst validInfo = $dt<UseControllableValueOptions>({\n  defaultValuePropName: $t.validString('defaultValue'),\n  valuePropName: $t.validString('value'),\n  trigger: $t.validString('onChange'),\n});\n\nexport type PublicUseControllableValueOptions<\n  Ks extends PropertyKey = PropertyKey,\n  P extends Ks | (string & {}) = 'value',\n> = Partial<UseControllableValueOptions<Ks, P>>;\n\ntype ValueType<T extends Record<PropertyKey, any>, P> = NotUnion<P> extends true\n  ? P extends keyof T\n    ? T[P]\n    : T['value']\n  : T['value'];\n\n/**\n * 受控组件 value 逻辑切换, 如果传递了 value 则走受控逻辑, 否则走非受控逻辑\n */\nexport function useControllableValue<\n  T extends Record<PropertyKey, any>,\n  P extends keyof T | (string & {}) = PropertyKey,\n>(props = {} as T, options: PublicUseControllableValueOptions<keyof T, P> = {}) {\n  const { result: validOptions } = useValidData(options as UseControllableValueOptions, validInfo) as {\n    result: UseControllableValueOptions;\n  };\n  const { defaultValue: _defaultValue, trigger, valuePropName, defaultValuePropName } = validOptions;\n  const {\n    [valuePropName]: propValue,\n    [defaultValuePropName]: defaultValue = _defaultValue,\n    [trigger]: emitChange,\n  } = props;\n\n  const hasValueRef = useRef(Boolean(Reflect.getOwnPropertyDescriptor(props, valuePropName)));\n  const isFirstRenderRef = useRef(true);\n\n  const [ctrlValue, setCtrlValue] = useState(hasValueRef.current ? (propValue as ValueType<T, P>) : defaultValue);\n\n  const setValue = useEffectEvent((value: ValueType<T, P>, ...args: any[]) => {\n    if (typeof emitChange === 'function') {\n      emitChange(value, ...args);\n    }\n    if (!hasValueRef.current) {\n      setCtrlValue(value);\n    }\n  });\n\n  useEffect(() => {\n    if (isFirstRenderRef.current || !hasValueRef.current) {\n      isFirstRenderRef.current = false;\n      return;\n    }\n    setCtrlValue(propValue as ValueType<T, P>);\n  }, [propValue]);\n\n  return [ctrlValue, setValue] as [ValueType<T, P>, typeof setValue];\n}\n"
    }
  ]
}