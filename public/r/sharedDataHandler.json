{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "title": "sharedDataHandler",
  "name": "sharedDataHandler",
  "description": "sharedDataHandler",
  "registryDependencies": [
    "./public/r/sharedThrowError.json"
  ],
  "dependencies": [],
  "type": "registry:item",
  "files": [
    {
      "path": "src/shared/data-handler/index.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/shared/data-handler/index.ts",
      "content": "import { throwType } from '../throw-error';\nimport type { ActionContext, ActionHandlers, Actions, DataHandlerOptions, Handler } from './types';\n\nfunction createActions() {\n  const ctx: ActionContext = {\n    errors: [],\n    transforms: [],\n    handledErrorKeys: new Set(),\n  };\n\n  const handler: ActionHandlers = {\n    addError(key, msg = `${String(key)} is not valid`) {\n      if (ctx.handledErrorKeys.has(key)) {\n        return;\n      }\n      ctx.handledErrorKeys.add(key);\n      ctx.errors.push(msg);\n    },\n    addTransform(key, value) {\n      ctx.transforms.push([key, value]);\n    },\n  };\n\n  return [\n    ctx,\n    handler,\n    (key: PropertyKey) =>\n      ({\n        assert: (flag, msg = `${String(key)} is not valid`) => {\n          if (!flag) {\n            handler.addError(key, msg);\n          }\n          return flag;\n        },\n        transform: (value) => {\n          if (!ctx.handledErrorKeys.has(key)) {\n            handler.addTransform(key, value);\n          }\n          return value;\n        },\n      }) satisfies Actions,\n  ] as const;\n}\n\nfunction transformApply(data: Record<PropertyKey, any>, transforms: [PropertyKey, any][]) {\n  if (!transforms.length) {\n    return;\n  }\n  for (let i = 0, [key, value] = transforms[i]; i < transforms.length; [key, value] = transforms[++i] || []) {\n    data[key] = value;\n  }\n}\n\nfunction handleProcess(\n  data: Record<PropertyKey, any>,\n  keys: PropertyKey[],\n  handleFn: Handler<any> & ((...args: any[]) => any),\n  getActions: (key: PropertyKey) => Actions,\n  actionHandlers: ActionHandlers,\n) {\n  for (let i = 0, key = keys[i]; i < keys.length; key = keys[++i]) {\n    const flag = handleFn(data[key], key as PropertyKey, getActions(key), data);\n    if (flag === false) {\n      actionHandlers.addError(key);\n    }\n  }\n}\n\nfunction errorProcess(errors: string[], errorHandler?: (error: string[]) => void, strict?: boolean) {\n  if (!errors.length) {\n    return;\n  }\n  if (errorHandler) {\n    errorHandler(errors);\n  } else if (strict) {\n    throwType(errors.join('\\n'));\n  }\n}\n\nfunction filterData(data: Record<PropertyKey, any>, ctx: ActionContext, defaultValue: Record<PropertyKey, any> = {}) {\n  ctx.handledErrorKeys.forEach((key) => {\n    data[key] = defaultValue[key];\n  });\n}\n\nexport function dataHandler<\n  M extends Record<PropertyKey, any>,\n  O extends DataHandlerOptions<M> = DataHandlerOptions<M>,\n>(\n  data: M & Partial<O['defaultValue']>,\n  handler: Handler<M>,\n  options?: O,\n): { result: M & O['defaultValue']; errors: string[] } {\n  if (!handler) {\n    throwType('handler is required');\n  }\n  const { strict = false, errorHandler, defaultValue } = options || {};\n  const handlerIsFunction = typeof handler === 'function';\n  const handleFn = handlerIsFunction\n    ? handler\n    : (value: any, key: PropertyKey, ...args: [Actions, M]) => handler[key]!(value, ...args);\n\n  const tempData: Record<PropertyKey, any> = { ...defaultValue, ...data };\n\n  const keys = handlerIsFunction ? Reflect.ownKeys(data) : Reflect.ownKeys(handler);\n  const [ctx, actionHandler, getActions] = createActions();\n\n  handleProcess(tempData, keys, handleFn, getActions, actionHandler);\n\n  errorProcess(ctx.errors, errorHandler, strict);\n\n  transformApply(tempData, ctx.transforms);\n\n  filterData(tempData, ctx, defaultValue);\n\n  return { result: tempData, errors: ctx.errors };\n}\n\nexport * from './tools';\n"
    },
    {
      "path": "src/shared/data-handler/types.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/shared/data-handler/types.ts",
      "content": "export interface Actions {\n  assert: <T extends boolean>(flag: T, msg?: string) => T;\n  /**\n   * 转换结果中的数值类型\n   *\n   * @warning 如果被 assert 处理为 false, 则不会应用转换\n   */\n  transform: <T>(value: T) => T;\n}\n\nexport type Handler<M extends Record<PropertyKey, any>> =\n  | Partial<{\n      [K in keyof M]: (value: M[K], action: Actions, option: M) => false | (any & {});\n    }>\n  | (<K extends keyof M>(value: M[K], key: K, action: Actions, option: M) => false | (any & {}));\n\nexport interface ActionContext {\n  errors: string[];\n  transforms: [PropertyKey, any][];\n  handledErrorKeys: Set<PropertyKey>;\n}\n\nexport interface ActionHandlers {\n  addError(key: PropertyKey, msg?: string): void;\n  addTransform(key: PropertyKey, value: any): void;\n}\n\nexport interface DataHandlerOptions<M extends Record<PropertyKey, any>> {\n  strict?: boolean;\n  errorHandler?: (error: ActionContext['errors']) => void;\n  defaultValue?: M;\n}\n"
    },
    {
      "path": "src/shared/data-handler/tools.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/shared/data-handler/tools.ts",
      "content": "import { logger } from '../logger';\nimport type { Handler } from './types';\n\nfunction getType(_v: any) {\n  return Object.prototype.toString.call(_v).slice(8, -1).toLowerCase();\n}\n\ntype TypeHandler = NonNullable<Exclude<Handler<any>, (...args: any[]) => any>[string]>;\n\ntype Fullback = ((_v: any) => any) | (any & {});\n\nfunction typeHandler(type: any, verifyFn?: (_v: any) => boolean) {\n  return (fullback?: Fullback): TypeHandler =>\n    (_v, actions) => {\n      if (verifyFn ? verifyFn(_v) : getType(_v) === type) {\n        return true;\n      }\n      if (fullback == null) {\n        return false;\n      }\n      let fullbackValue = fullback;\n      if (typeof fullback === 'function') {\n        fullbackValue = fullback(_v);\n      }\n      actions.transform(fullbackValue);\n    };\n}\n\nexport const $t = {\n  notNullable: typeHandler('notNullable', (_v) => _v != null),\n  string: typeHandler('string'),\n  validString: typeHandler('validString', (_v) => typeof _v === 'string' && _v.length > 0),\n  number: typeHandler('number'),\n  validNumber: typeHandler('validNumber', (_v) => typeof _v === 'number' && !Number.isNaN(_v)),\n  boolean: typeHandler('boolean'),\n  object: typeHandler('object'),\n  array: typeHandler('array'),\n  function: typeHandler('function'),\n  symbol: typeHandler('symbol'),\n} satisfies Record<string, () => TypeHandler>;\n\nexport function defineTransform<T extends Record<PropertyKey, any>>(\n  dataInfo: Partial<Record<keyof T, keyof typeof $t | TypeHandler>>,\n) {\n  const verifyInfo: Record<PropertyKey, TypeHandler> = {};\n  const keys = Reflect.ownKeys(dataInfo);\n  for (let i = 0, key = keys[i], item = dataInfo[key]; i < keys.length; key = keys[++i], item = dataInfo[key]) {\n    if (typeof item === 'function') {\n      verifyInfo[key] = item;\n      continue;\n    }\n    const handler = $t[item as keyof typeof $t];\n    if (!handler) {\n      logger.warn(`${item} is not a valid type`);\n      continue;\n    }\n    verifyInfo[key] = handler();\n  }\n  return verifyInfo;\n}\n\nexport const $dt = defineTransform;\n"
    },
    {
      "path": "src/shared/logger/index.ts",
      "type": "registry:file",
      "target": "~/src/cmtlyt/lingshu-toolkit/src/shared/logger/index.ts",
      "content": "export const logger = new Proxy(console, {\n  get(target, prop, receiver) {\n    const oldLog = Reflect.get(target, prop, receiver).bind(console);\n    return (...args: any) => {\n      oldLog('[@cmtlyt/lingshu-toolkit]:', ...args);\n    };\n  },\n});\n"
    }
  ]
}